<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>陈奇峰 Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #webcam-video { 
            /* 隐藏摄像头预览，但 MediaPipe 仍需要它来处理帧 */
            position: absolute;
            top: 0;
            left: 0;
            visibility: hidden;
            z-index: -1; 
        }
        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        /* 样式化 dat.GUI 使其更现代 */
        .dg.main {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            opacity: 0.9;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <video id="webcam-video" autoplay></video>
    
    <button id="fullscreen-btn">全屏/退出</button>

    <script>
        // --- 全局变量声明 ---
        let scene, camera, renderer, particles, videoElement;
        let gui, guiControls;
        let hands;
        let particleCount = 50000;
        let particlePositions;
        
        // --- 核心控制参数 ---
        guiControls = {
            particleColor: '#ff9900', // 初始粒子颜色
            modelType: 'heart',       // 初始模型
            particleSize: 0.02,
            fullScreen: () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
        };

        // --- 初始化函数 ---
        function init() {
            // 1. 设置 Three.js 场景
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 3;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x111111, 1);
            document.body.appendChild(renderer.domElement);

            // 2. 初始化粒子系统
            initializeParticles();
            
            // 3. 设置 UI 面板
            setupGUI();
            
            // 4. 初始化 MediaPipe 和摄像头
            setupMediaPipe();

            // 5. 事件监听
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('fullscreen-btn').addEventListener('click', guiControls.fullScreen);

            animate();
        }

        // --- 粒子初始化与几何体生成 ---
        function initializeParticles() {
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(particleCount * 3);
            
            // 初始生成点集 (默认爱心模型)
            generatePoints('heart'); 

            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

            const material = new THREE.PointsMaterial({
                color: guiControls.particleColor,
                size: guiControls.particleSize,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 模型点集生成函数 (占位符) ---
        function generatePoints(type) {
            console.log(`正在生成 ${type} 模型点集...`);
            // 此处需要实现各种模型的数学生成逻辑 (如爱心参数方程) 或 GLTF 顶点提取
            
            // 示例：简单球形点阵
            const radius = 1;
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const r = radius * Math.cbrt(Math.random()); // 随机半径
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                particlePositions[i3]     = r * Math.sin(phi) * Math.cos(theta);
                particlePositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                particlePositions[i3 + 2] = r * Math.cos(phi);
            }
            
            if (particles) {
                 particles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // --- UI 控制面板设置 ---
        function setupGUI() {
            gui = new dat.GUI();
            gui.domElement.id = 'gui';
            
            // 颜色选择器
            gui.addColor(guiControls, 'particleColor').onChange((value) => {
                particles.material.color.set(value);
            }).name('粒子颜色');

            // 模型选择器
            gui.add(guiControls, 'modelType', {
                '爱心 (Heart)': 'heart',
                '花朵 (Flower)': 'flower',
                '土星 (Saturn)': 'saturn',
                '佛像 (Buddha)': 'buddha', 
                '烟花 (Firework)': 'firework'
            }).onChange(generatePoints).name('粒子模型');

            // 粒子大小
            gui.add(guiControls, 'particleSize', 0.005, 0.1).step(0.001).onChange((value) => {
                particles.material.size = value;
            }).name('粒子大小');

            // 全屏按钮 (虽然在外部有，但也可以在 GUI 中添加)
            gui.add(guiControls, 'fullScreen').name('全屏控制');

            gui.open();
        }

        // --- MediaPipe 手势追踪设置 ---
        async function setupMediaPipe() {
            videoElement = document.getElementById('webcam-video');
            
            // 启动摄像头
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = resolve;
                });
                videoElement.play();
            } catch (err) {
                console.error("无法访问摄像头: ", err);
                return;
            }

            // 初始化 Hands
            hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
            
            // 持续向 MediaPipe 发送视频帧
            const sendFrameToMediaPipe = async () => {
                if (videoElement.readyState >= 2) { // 确保视频已加载足够的帧
                    await hands.send({image: videoElement});
                }
                requestAnimationFrame(sendFrameToMediaPipe);
            };
            sendFrameToMediaPipe();
        }

        // --- MediaPipe 结果处理 (核心交互逻辑) ---
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandedness.length > 0) {
                
                // 仅处理第一只手
                const landmarks = results.multiHandLandmarks[0];
                
                // 关键点：拇指尖 (4) 和食指尖 (8)
                const thumbTip = landmarks[4]; 
                const indexTip = landmarks[8];
                
                // 计算捏合距离（归一化坐标 0-1）
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                    // MediaPipe 提供的 z 轴通常噪声较大，此处简化为 2D 距离
                );

                // 映射距离到粒子扩散/缩放因子
                // 假设：距离 0.05 对应收缩，距离 0.25 对应扩散
                const minDistance = 0.05;
                const maxDistance = 0.25;
                
                // 将距离标准化到 0.0 到 1.0 范围 (0.0 = 收缩，1.0 = 扩散)
                const normalizedFactor = THREE.MathUtils.clamp(
                    (distance - minDistance) / (maxDistance - minDistance), 
                    0, 
                    1
                );
                
                // 调用粒子更新函数
                updateParticles(normalizedFactor);

            } else {
                // 如果没有检测到手，粒子逐渐恢复默认状态
                updateParticles(0.5); // 恢复到中等状态
            }
        }
        
        // --- 粒子状态实时更新函数 ---
        function updateParticles(factor) {
            // Factor 0.0: 收缩 / Factor 1.0: 扩散
            const maxDisplacement = 5.0 * factor;
            
            // 简单地缩放整个粒子系统
            const targetScale = 0.5 + 1.5 * factor; // 缩放范围 0.5 到 2.0
            
            // 缓动动画让缩放更平滑 (可选)
            particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);

            // 也可以在这里基于 factor 修改粒子几何体的位置，实现更复杂的扩散效果
        }

        // --- 窗口重置处理 ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 渲染循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            // 动画效果 (例如自转)
            particles.rotation.y += 0.005;

            renderer.render(scene, camera);
        }

        // --- 启动应用 ---
        init();

    </script>
</body>
</html>
