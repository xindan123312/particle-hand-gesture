<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>陈奇峰 Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #webcam-video { 
            /* 隐藏摄像头预览，但 MediaPipe 仍需要它来处理帧 */
            position: absolute;
            top: 0;
            left: 0;
            visibility: hidden;
            z-index: -1; 
        }
        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        /* 样式化 dat.GUI 使其更现代 */
        .dg.main {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            opacity: 0.9;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <video id="webcam-video" autoplay></video>
    
    <button id="fullscreen-btn">全屏/退出</button>

    <script>
        // --- 全局变量声明 ---
        let scene, camera, renderer, particles, videoElement;
        let gui, guiControls;
        let hands;
        let particleCount = 50000; 
        let particlePositions; 
        
        // --- 核心控制参数 ---
        guiControls = {
            particleColor: '#ff9900', 
            modelType: 'heart',      
            particleSize: 0.02,
            fullScreen: () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
        };

        // --- 初始化函数 ---
        function init() {
            // 1. 设置 Three.js 场景
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 8; // **【尺寸回调】相机后移到 z=8，适中距离**
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x111111, 1); 
            document.body.appendChild(renderer.domElement);

            // 2. 初始化粒子系统
            initializeParticles();
            
            // 3. 设置 UI 面板
            setupGUI();
            
            // 4. 初始化 MediaPipe 和摄像头
            setupMediaPipe();

            // 5. 事件监听
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('fullscreen-btn').addEventListener('click', guiControls.fullScreen);

            animate(); 
        }

        // --- 粒子初始化与几何体生成 ---
        function initializeParticles() {
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(particleCount * 3);
            
            generatePoints(guiControls.modelType); 

            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

            const material = new THREE.PointsMaterial({
                color: guiControls.particleColor,
                size: guiControls.particleSize,
                blending: THREE.AdditiveBlending, 
                transparent: true,
                depthWrite: false 
            });

            particles = new THREE.Points(geometry, material); 
            scene.add(particles);
        }

        // --- 模型点集生成函数 (已实现 'heart' 模型) ---
        function generatePoints(type) {
            console.log(`正在生成 ${type} 模型点集...`);
            
            if (!particlePositions || particlePositions.length !== particleCount * 3) {
                particlePositions = new Float32Array(particleCount * 3);
            }
            
            let posIndex = 0; 

            switch (type) {
                case 'heart':
                    const scale = 1.0;
                    const customScale = 3.0; // **【尺寸回调】模型基础尺寸回调到 3.0**
                    
                    for (let i = 0; i < particleCount; i++) {
                        const t = Math.random() * 2 * Math.PI; 
                        const u = Math.random() * Math.PI;     
                        const r = 0.8 + 0.2 * Math.random(); 

                        const x_base = 16 * Math.pow(Math.sin(t), 3);
                        const y_base = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                        
                        const Px = scale * r * Math.sin(u) * x_base / 20;
                        const Py = scale * r * (y_base / 20); 
                        const Pz = scale * r * Math.cos(u) * x_base / 20;

                        // 应用新的缩放系数 (3.0)
                        particlePositions[posIndex++] = Px * customScale; 
                        particlePositions[posIndex++] = Py * customScale;
                        particlePositions[posIndex++] = Pz * customScale;
                    }
                    break;
                    
                case 'flower':
                case 'saturn':
                case 'buddha':
                case 'firework':
                default:
                    const radius = 1;
                    for (let i = 0; i < particleCount; i++) {
                        const r = radius * Math.cbrt(Math.random());
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(Math.random() * 2 - 1);
                        
                        particlePositions[posIndex++] = r * Math.sin(phi) * Math.cos(theta);
                        particlePositions[posIndex++] = r * Math.sin(phi) * Math.sin(theta);
                        particlePositions[posIndex++] = r * Math.cos(phi);
                    }
                    break;
            }

            if (particles) {
                particles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // --- UI 控制面板设置 ---
        function setupGUI() {
            gui = new dat.GUI();
            gui.domElement.id = 'gui';
            
            gui.addColor(guiControls, 'particleColor').onChange((value) => {
                particles.material.color.set(value);
            }).name('粒子颜色');

            gui.add(guiControls, 'modelType', {
                '爱心 (Heart)': 'heart',
                '花朵 (Flower)': 'flower',
                '土星 (Saturn)': 'saturn',
                '佛像 (Buddha)': 'buddha', 
                '烟花 (Firework)': 'firework'
            }).onChange(generatePoints).name('粒子模型');

            gui.add(guiControls, 'particleSize', 0.005, 0.1).step(0.001).onChange((value) => {
                particles.material.size = value;
            }).name('粒子大小');

            gui.add(guiControls, 'fullScreen').name('全屏控制');

            gui.open();
        }

        // --- MediaPipe 手势追踪设置 ---
        async function setupMediaPipe() {
            videoElement = document.getElementById('webcam-video');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = resolve;
                });
                videoElement.play();
            } catch (err) {
                console.error("无法访问摄像头: ", err); 
                return;
            }

            hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1, 
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults); 
            
            const sendFrameToMediaPipe = async () => {
                if (videoElement.readyState >= 2) { 
                    await hands.send({image: videoElement}); 
                }
                requestAnimationFrame(sendFrameToMediaPipe);
            };
            sendFrameToMediaPipe(); 
        }

        // --- MediaPipe 结果处理 (核心交互逻辑) ---
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandedness.length > 0) {
                
                const landmarks = results.multiHandLandmarks[0]; 
                
                const thumbTip = landmarks[4]; 
                const indexTip = landmarks[8];
                
                // 计算捏合距离（归一化坐标 0-1）
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const minDistance = 0.05; 
                const maxDistance = 0.25; 
                
                const normalizedFactor = THREE.MathUtils.clamp(
                    (distance - minDistance) / (maxDistance - minDistance), 
                    0, 
                    1
                );
                
                updateParticles(normalizedFactor);

            } else {
                updateParticles(0.5); 
            }
        }
        
        // --- 粒子状态实时更新函数 (捏合手势驱动) ---
        function updateParticles(factor) {
            // 动态缩放范围保持 1.0 到 3.0 倍
            const targetScale = 1.0 + 2.0 * factor; 
            
            particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
        }

        // --- 窗口重置处理 ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 渲染循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            particles.rotation.y += 0.005;

            renderer.render(scene, camera);
        }

        // --- 启动应用 ---
        init();

    </script>
</body>
</html>
